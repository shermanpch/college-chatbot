import os

from langchain.chains.query_constructor.base import (
    StructuredQueryOutputParser,
    get_query_constructor_prompt,
)
from langchain.retrievers.self_query.base import SelfQueryRetriever
from langchain_chroma import Chroma
from langchain_community.query_constructors.chroma import ChromaTranslator
from langchain_core.documents import Document
from langchain_core.structured_query import Comparison, Operation
from langchain_openai import ChatOpenAI

from chatbot.components.attributes import PETERSON_METADATA_FIELDS
from chatbot.utils.prompt_loader import load_prompt
from projectutils.env import setup_project_environment
from projectutils.logger import setup_logger

# Call setup at the module level
PROJECT_ROOT, _ = setup_project_environment()

# Set up logging using the new utility
logger = setup_logger(__file__)


class FixedFilterSelfQueryRetriever(SelfQueryRetriever):
    """
    Enhanced SelfQueryRetriever that properly combines fixed filters with LLM-generated filters.

    Unlike the base SelfQueryRetriever, this class ensures that fixed filters specified in
    search_kwargs are always applied in combination with any filters generated by the LLM.
    """

    fixed_filters: dict = {}

    def __init__(self, fixed_filters: dict = None, **kwargs):
        # Remove fixed_filters from kwargs if present to avoid conflicts
        if "fixed_filters" in kwargs:
            kwargs.pop("fixed_filters")
        super().__init__(**kwargs)
        # Use object.__setattr__ to bypass Pydantic validation
        object.__setattr__(self, "fixed_filters", fixed_filters or {})

    def invoke(self, input: str, config=None, **kwargs) -> list[Document]:
        """
        Invoke the retriever with proper fixed filter combination.

        Strategy: Merge fixed filters with LLM-generated filters into a single
        combined filter and apply directly to Chroma.
        """
        try:
            # Log LLM invocation for query construction
            logger.info(
                f"LLM CALL: Invoking query constructor for structured query generation with input: '{input[:100]}{'...' if len(input) > 100 else ''}'"
            )

            # Generate structured query using LLM first
            structured_query = self.query_constructor.invoke({"query": input})
            query_text = structured_query.query or input

            # Determine the appropriate filter to use
            if self.fixed_filters or structured_query.filter:
                combined_filter = self._merge_filters(
                    self.fixed_filters, structured_query.filter
                )

                if combined_filter:
                    results = self._execute_search(query_text, combined_filter)
                    logger.info(f"Combined filter returned {len(results)} documents")
                    return results

            # No filters to apply, use standard behavior
            return super().invoke(input, config, **kwargs)

        except Exception as e:
            logger.error(f"Error in FixedFilterSelfQueryRetriever.invoke: {e}")
            raise

    def _execute_search(self, query_text: str, chroma_filter: dict) -> list[Document]:
        """
        Execute similarity search with proper search kwargs setup.

        Args:
            query_text: The text query for semantic search
            chroma_filter: The Chroma-formatted filter to apply

        Returns:
            List of retrieved documents
        """
        search_kwargs = {"filter": chroma_filter}

        # Merge with existing search_kwargs, excluding filter
        if hasattr(self, "search_kwargs") and self.search_kwargs:
            for key, value in self.search_kwargs.items():
                if key != "filter":
                    search_kwargs[key] = value

        return self.vectorstore.similarity_search(query_text, **search_kwargs)

    def _create_filter_condition(self, key: str, value) -> dict:
        """
        Create a single filter condition with appropriate operator.

        Args:
            key: The metadata field name
            value: The value(s) to filter by

        Returns:
            Chroma-formatted filter condition
        """
        if isinstance(value, list):
            return {key: {"$in": value}}
        else:
            return {key: {"$eq": value}}

    def _merge_filters(self, fixed_filters: dict, llm_filter) -> dict:
        """
        Merge simple fixed filters with complex LLM-generated filters.

        Args:
            fixed_filters: Simple key-value filters like {"state": "California"}
            llm_filter: Complex nested filter from LLM (can be None)

        Returns:
            Combined filter in Chroma format
        """
        if not fixed_filters and not llm_filter:
            return {}

        # Convert simple fixed filters to Chroma operator format
        fixed_conditions = []
        for key, value in (fixed_filters or {}).items():
            fixed_conditions.append(self._create_filter_condition(key, value))

        # Convert LLM filter to Chroma format using the translator
        llm_chroma_filter = None
        if llm_filter:
            try:
                # Use the ChromaTranslator to convert structured query filter to Chroma format
                # Check the type of filter and use appropriate method

                if isinstance(llm_filter, Comparison):
                    llm_chroma_filter = (
                        self.structured_query_translator.visit_comparison(llm_filter)
                    )
                elif isinstance(llm_filter, Operation):
                    llm_chroma_filter = (
                        self.structured_query_translator.visit_operation(llm_filter)
                    )
                else:
                    # Fallback: try the generic visit method
                    llm_chroma_filter = self.structured_query_translator.visit(
                        llm_filter
                    )

            except Exception as e:
                logger.warning(f"Could not translate LLM filter to Chroma format: {e}")
                llm_chroma_filter = None

        # Combine the filters
        if fixed_conditions and llm_chroma_filter:
            # Both exist - combine them with $and
            combined_filter = {"$and": fixed_conditions + [llm_chroma_filter]}
            return combined_filter
        elif fixed_conditions:
            # Only fixed filters
            if len(fixed_conditions) == 1:
                result = fixed_conditions[0]
            else:
                result = {"$and": fixed_conditions}
            return result
        elif llm_chroma_filter:
            # Only LLM filter
            return llm_chroma_filter
        else:
            return {}


def create_self_query_retriever(
    vectorstore: Chroma,
    k: int = 50,
    fixed_filters: dict = None,
) -> FixedFilterSelfQueryRetriever:
    """
    Create a SelfQueryRetriever for Peterson university data with proper fixed filter support.

    This retriever can understand natural language queries and automatically
    construct appropriate metadata filters based on the comprehensive Peterson
    university dataset structure. Fixed filters will always be applied in combination
    with any LLM-generated filters using AND logic.

    Args:
        vectorstore: The Chroma vector store instance
        k: Number of documents to retrieve
        fixed_filters: Dictionary of fixed metadata filters to always apply
                      (e.g., {"region": "Pacific", "document_id": "abc123"})

    Returns:
        Configured FixedFilterSelfQueryRetriever instance with proper filter combination
    """
    # Build query-constructor chain using OpenRouter
    model_name = os.getenv("OPENROUTER_SELF_RETRIEVAL_MODEL", "openai/gpt-4o-mini")
    logger.info(f"Creating SelfQueryRetriever with LLM model: {model_name}")

    llm = ChatOpenAI(
        model=model_name,
        temperature=0.0,
        seed=69,
        max_retries=3,
        base_url="https://openrouter.ai/api/v1",
        api_key=os.getenv("OPENROUTER_API_KEY"),
        default_headers={
            "HTTP-Referer": "http://localhost:8000",
            "X-Title": "College Chatbot",
        },
    )

    # Load document content description from template
    self_retrieval_prompt = load_prompt("self_retrieval.md")

    prompt = get_query_constructor_prompt(
        self_retrieval_prompt,
        PETERSON_METADATA_FIELDS,
    )
    parser = StructuredQueryOutputParser.from_components()
    query_constructor = prompt | llm | parser  # LCEL pipeline

    # Create FixedFilterSelfQueryRetriever with proper filter combination
    retriever = FixedFilterSelfQueryRetriever(
        query_constructor=query_constructor,
        vectorstore=vectorstore,
        structured_query_translator=ChromaTranslator(),
        search_kwargs={"k": k},
        fixed_filters=fixed_filters,
    )

    if fixed_filters:
        logger.debug(f"Created retriever with fixed filters: {fixed_filters}")

    return retriever


def get_structured_query_details(
    retriever: SelfQueryRetriever, user_query: str
) -> dict[str, str]:
    """
    Extract the structured query components for logging.

    Args:
        retriever: The SelfQueryRetriever instance
        user_query: Natural language query from the user

    Returns:
        Dictionary with query components:
        {
            "fixed_filters": "raw fixed filters dict",
            "search_query": "search text from LLM",
            "metadata_filters": "raw LLM filter object as string",
            "combined_metadata": "actual combined filter using _merge_filters logic",
            "limit": "number limit"
        }
    """
    try:
        # Get the query constructor from the retriever
        query_constructor = retriever.query_constructor

        # Log LLM invocation for query analysis
        logger.info(
            f"LLM CALL: Invoking query constructor for query details analysis with input: '{user_query[:100]}{'...' if len(user_query) > 100 else ''}'"
        )

        # Invoke the query constructor to get the structured query
        structured_query = query_constructor.invoke({"query": user_query})

        # Extract search query
        search_query = structured_query.query or "No search text"

        # Extract limit
        limit = str(structured_query.limit) if structured_query.limit else "No limit"

        # Extract fixed filters
        fixed_filters = ""
        if hasattr(retriever, "fixed_filters") and retriever.fixed_filters:
            fixed_filters = str(retriever.fixed_filters)

        # Extract LLM metadata filters
        metadata_filters = (
            str(structured_query.filter) if structured_query.filter else ""
        )

        # Get the actual combined metadata using _merge_filters logic
        combined_metadata = ""
        if isinstance(retriever, FixedFilterSelfQueryRetriever):
            try:
                actual_combined_filter = retriever._merge_filters(
                    retriever.fixed_filters, structured_query.filter
                )
                combined_metadata = (
                    str(actual_combined_filter) if actual_combined_filter else ""
                )
            except Exception as e:
                logger.warning(f"Could not generate combined filter: {e}")
                # Fallback to simple string concatenation
                combined_parts = []
                if metadata_filters:
                    combined_parts.append(f"LLM: {metadata_filters}")
                if fixed_filters:
                    combined_parts.append(f"Fixed: {fixed_filters}")
                combined_metadata = (
                    " AND ".join(combined_parts) if combined_parts else ""
                )
        else:
            # For non-FixedFilterSelfQueryRetriever, use simple concatenation
            combined_parts = []
            if metadata_filters:
                combined_parts.append(f"LLM: {metadata_filters}")
            if fixed_filters:
                combined_parts.append(f"Fixed: {fixed_filters}")
            combined_metadata = " AND ".join(combined_parts) if combined_parts else ""

        return {
            "fixed_filters": fixed_filters,
            "search_query": search_query,
            "metadata_filters": metadata_filters,
            "combined_metadata": combined_metadata,
            "limit": limit,
        }

    except Exception as e:
        logger.warning(f"Could not extract structured query details: {e}")
        error_msg = f"Error: {str(e)}"
        return {
            "fixed_filters": error_msg,
            "search_query": error_msg,
            "metadata_filters": error_msg,
            "combined_metadata": error_msg,
            "limit": error_msg,
        }


def create_fixed_filters(**filters) -> dict:
    """
    Helper function to create fixed filters dictionary.

    Supports both single values and lists of values:
    - Single values use $eq operator
    - Lists use $in operator

    Examples:
        # Filter to specific document
        filters = create_fixed_filters(document_id="abc123")

        # Filter to multiple documents
        filters = create_fixed_filters(
            document_id=["2d135c90cdad2fac7471fd28e3d5ca18", "8e0bc77698b702c2124b7a3642239e68"]
        )

        # Filter to Pacific region only
        filters = create_fixed_filters(region="Pacific")

        # Filter to multiple regions
        filters = create_fixed_filters(region=["Pacific", "Midwest"])

        # Filter to schools with housing and specific states
        filters = create_fixed_filters(
            college_owned_housing=True,
            state=["California", "New York", "Texas"]
        )

    Args:
        **filters: Keyword arguments representing metadata field filters.
                  Values can be single items or lists.

    Returns:
        Dictionary of fixed filters ready for use with SelfQueryRetriever
    """
    return filters
